class05
=============

Service
===========


IMP: Services Identifies the pods base on labels & selectors

$ kubectl api-resources ==>API resource 

$ kubectl get pods --show-labels -n test-ns

$kubectl get po -n test-ns --show-labels
$kubectl get svc -n test-ns -o wide


ClusterIP 

it will reachable within the cluster

Communication is happen inside the cluster only  

apiVersion: v1
kind: Service
metadata:
  name: <serviceName>
  labels:
   <key>: <value>
  namespace: <namespace> 
spec:
  type: ClusterIP
  selector:
   <podLabelKey>: <podLabelValue>
   <podLabelKey>: <podLabelValue>
  ports:
  - port: <serviceport>
    targetPort: <ContainerPort>


----
Eg:

apiVersion: v1
kind: Pod
metadata:
  labels:
    app: mavenwebapp
  name: mavenwebapppod
  namespace: test-ns
spec:
  containers:
    - image: naniravi/java-web-app:1
      name: mavenwebapppod
      ports:
        - containerPort: 8080



app: key
value: mavenwebapp

---

apiVersion: v1
kind: Service
metadata:
   name: mavenwebappsvc
   namespace: test-ns
spec:
  type: ClusterIP
  selector:
    app: mavenwebapp
  ports:
  - port: 80
    targetPort: 8080


$ kubectl apply -f mavenwebapppod.yaml --dry-run=client==>kubectl will not goes to API Server kuberctlitself will validate 
$ kubectl apply -f mavenwebapppod.yaml --dry-run=server==>requeest goes to api server 	



vi javawebapppod.yaml

apiVersion: v1
kind: Pod
metadata:
  name: javawebappod
  namespace: test-ns
  labels:
    app: javawebapp
spec:
  containers:
  - name: javawebappcontainer
    image: naniravi/java-web-app:1
    ports:
    - containerPort: 8080
---
apiVersion: v1
kind: Service
metadata:
  name: javaweappsvc
  namespace: test-ns
spec:
  type: ClusterIP
  selector:
    app: javawebapp
  ports:
  - port: 80
    targetPort: 8080


$kubectl apply -f  javawebapppod.yaml





   

